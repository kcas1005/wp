실험실 & 기록실
    -----------------------------------------------------------------------
    -----------------------------------------------------------------------
    -----------------------------------------------------------------------
    -----------------------------------------------------------------------
    -----------------------------------------------------------------------
    -----------------------------------------------------------------------
    -----------------------------------------------------------------------
    -----------------------------------------------------------------------

    Advanced REST client
                https://chrome.google.com/webstore/detail/advanced-rest-client/hgmloofddffdnphfgcellkdfbfbjeloo
    -----------------------------------------------------------------------

[zoom]
        791 333 9157 / ZkXC6X
        https://js3322.github.io/exam/
        https://share.goodnotes.com/s/zIZ2noPbGkJ8KdeTe4bmPl#page-1
        https://cafe.naver.com/grapec
        프로젝트 깃 토큰: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
        만료일:12월
        이수민 선생님 카페: https://cafe.naver.com/grapec
        김준석 선생님 깃주소:https://github.com/JS3322
    -----------------------------------------------------------------------

    휴먼 pdf 암호
    71614
    -----------------------------------------------------------------------

    [잡플래닛 기업정보보기]
    www.jobplanet.co.kr
    ID : js.cleancode@gmail.com
    PW : System12341234@
    -----------------------------------------------------------------------

    adoptium 다운 받는 곳
    https://adoptium.net/temurin/releases?version=8
    -----------------------------------------------------------------------

     깃 토큰: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
     만료일:12월

    -----------------------------------------------------------------------
    DB
        테이블을 삭제할때 ERD로 확인하고 삭제하기
        관계가 들어가면 삭제가 안되는데 삭제하려고 Casecade 쓰는 순간 전체 데이터가 날아감
    -----------------------------------------------------------------------

    -----------------------------------------------------------------------
    리액트

    https://reactnative.dev/docs/getting-started

    -----------------------------------------------------------------------
    스프링부트

        스프링부트 프레임 워크 받는 곳
        https://start.spring.io/

        tymeleaf에서 th:text, th:name, th:value의 성격

        500에러 나오면 HTML @{/경로 설정 꼭 할 것} (화면, 값저장 둘다 안됨)
        404에러면 값은 저장되지만 화면 출력이 안됨
        공식 문서 오류 정리 : https://developer.mozilla.org/ko/docs/Web/HTTP/Status
        나무위키 오류 정리 : https://namu.wiki/w/HTTP/%EC%9D%91%EB%8B%B5%20%EC%BD%94%EB%93%9C

        회원정보 수정하기 오류 걸린이유(경로설정을 안해줘서)
            @RequestMapping(path = "/account")클래스 위에 이거 안넣어서 그럼

        댓글 만들기
            값 넣는 부분과 화면 출력 부분이 구분되어 있어야 했는데
            같은 곳에 넣음

            comment 필드값과 html 자바값 이름이 같아야 하는데 같지 않아서 헤맴

        게시판 글 일부분 20자 내로 보이게 하기
            size 입력했지만 안됨

        타임리프는 뭐하는 존재인가?
            자바에 값을 전달 받기 위함

        게시판
             게시판목록은 ArrayList로 index 번호로 구분을 하는데
             상세 게시판은 index 구분을 하지 않는데 어떻게 값을 알고 나오는가?
             필드값에 저장을 해둔다고 해도 index같은 구분이 없는데 어떻게 알고 출력되는가?
    -----------------------------------------------------------------------
    자바

        Override 와 Overload의 차이

        메소드와 함수의 차이
        객체안에 들어있으면 메소드라 부름

        함수 객체 메소드 생성자 명칭만 다르고 같은 기능을 하나?
            함수 = 메소드(실행) = 생성자
            객체 = 안에 클래스, 필드, 생성자 영역으로 나누어짐
            오버로딩 = 클래스와 메소드 명칭을 같게 해야함
            메소드 오버로딩 = 가능 하지만 현업에서 쓰이지 않음

        자바스크립트에서 함수가 중첩되서 매개변수 길이(개수) 안맞으면 undefied로 오류가 나는데 자바에는 왜 오류가 안나는가?
            자바스크립트는 함수를 덮어쓰기 때문에 매개변수와 인수 값을 정확하게 맞춰줘야하지만
            자바는 오버로딩으로 커버가 됨
            
        내부/외부 클래스 호출 =  내부/외부 오버로딩 호출 두개 혼동 중

        배열에서 null 값이 있을 시 Array를 사용 (Array 함수는 Null값이 들어감)

        부모,자식 상속, 인터페이스 상속 중첩 가능

        상위 상속이 없으면 형변환 안됨

        Enum과 String 배열 값은 서로 같음 대신 Enum을 쓸 땐 .equals()를 써야함
            그리고 배열은 길이를 .length 를하지만 Enum은 .Value를 씀

        배열에서 배열 안에 있는 값을 볼때는 Arrays.ToString(), 이중 배열 볼때는 Arrays.DeepToString()

        클래스끼리 값이 같은지 비교할 때는 instanceof를 씀

        Enum은 값을 추가 할 수 있을까?

        Enum을 출력하면 주소값이 보일까? 안에 값이 보일까?

        주소값이 보인다면 안에 값을 보려면 어떻게 해야 하나?

        static 으로 배열 만든 후 집어넣고 다시 실행하면 기존에 있던 값이 저장 되는가?
    -----------------------------------------------------------------------
    자바스크립트
        배열에 공백을 넣고 계산하면 NaN이 나오는데 null을 넣는다면 어떻게 될까?
            자바스크립트만 배열에 모든 타입을 집어넣을 수 있음
        STS(이클립스) jsp확장자에서 <%에 에러가 난다면
            자바 빌드가 설정 안되서 그런 것이다.
            프로젝트에서 > propertis에서 > 자바 빌드에서 > 라이브러리 추가 > 서버런타임 > tomcat 버전을 설정해 주면 된다.
    -----------------------------------------------------------------------
    HTML / CSS

        색 이쁜거 조합 사이트
        https://coolors.co/e8aeb7-062237-a9fff7-94fbab-82aba1
        https://www.palettable.io/211D1D

        CSS 스타일할때 포지션 같은거로 만들어두면 좋아보임

        span의 글은 텍스트 버티컬이 왜 안먹는가? display:table-cell, vertical-align 옵션 넣으면 됨
        플렉스는 블록이랑 호환 되는가? 호환됨
    -----------------------------------------------------------------------
    git
        깃 명령어
            https://velog.io/@delilah/GitHub-Git-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%AA%A8%EC%9D%8C
            https://nack1400.tistory.com/16

        .git 파일 숨김 표시로 되어있음

        vscode에선 팀프로젝트랑 연동이 잘 되서 팀프로젝트로 push가 가능했는데, 인텔리 제이에선 팀프로젝트가 연동이 안됨
            포크로 가져와서 사용
    -----------------------------------------------------------------------
    인텔리제이
    -----------------------------------------------------------------------
    vscode
    -----------------------------------------------------------------------
    정보
        https://huimang2.github.io/
    -----------------------------------------------------------------------
    취업 면접
    Day69
        #java String이 불변객체이어야하는 이유와 string builder,string buffer는 어떤 연관이 있나요?

            String은 불변객체인 이유로써 장점은 다음과 같습니다.
            메모리 관리면으로는 상수풀에서 이미 완성된 문자열을 가져다 씁니다. 그러므로 재활용성 의미로 메모리 절약이 됩니다.
            불변객체이므로 바꿀 수 없는 데이터로써 안정적인 장점을 가지며,
            main메서드에 보면 프로그램 외부에서 Args를 받는데 메타정보로 문자열이기 때문에 바뀌지 않는
            String 문자열은 불변성으로 보안성에 이득이 있습니다.

            String builder와 String buffer는 모두 String 의 불변객체를 보안하기 위한 기능입니다.
            String의 문자단위로 저장하고 추가할 수 있도록 size()와 apped()기능으로 메모리 할당과 추가 문자를 받아서
            새로운 문자로 만들 수 있습니다.

            String builder와 String buffer는 동기화와의 차이 있습니다.
            String buffer는 싱크로나이즈 기능으로 멀티 쓰레드에서 자원을 공유하는 문제에 있어 안정적입니다.
            (쓰레드는 메모리를 공유합니다. 그러므로 다른 문자열을 중간에 수정하거나 문제를 야기할 수 있으므로,
            동기화 기능을 통해 멀티쓰레드에서 안정성을 확보합니다.)
            String builder는 싱크로나이즈 기능이 없으므로, 중간에 문자열을 바꾸는 것을 막기 위한 메서드 실행이 안되므로
            속도적인 부분에 이득이 있습니다.

        #컴파일 과정과 프로그램 실행 흐름에 대해서 설명하시오.

            -컴파일
            자바 클래스 파일이 자바컴파일러(javac)가 바이트코드로 변환해주는 작업을 일컫습니다. (.java > .class)

            -런타임(프로그램 실행)
            .clss파일을 클래스 로더에서 읽어오고,
            JVM은 Just In Time(JIT)컴파일러가 런타임 시스템으로 어떠한 OS환경에서나 구동가능하게 합니다. (자바의 장점 : OS에 상관없이 JVM만 있으면 자바 프로그램 실행가능)

    Day70

        선생님 면접질문 답변 사이트 : https://gist.github.com/JS3322/46154f9bec967ec12f9518486cd58ea4
        #브라우저 동작원리에 대해 설명하시오

            1. User Interface
                UI(ex, button 등 태그)

            2. 브라우저 엔진
                데이터 스토리지 참조

            3. 렌더링 엔진
                 UI태그들을 HTML 문서에 파싱(문서화) >
                 DOM 구조 구축(HTML) >
                 CSSOM(CSS Object Model) css구조 구축 >
                 *DOM구조 구축되는 동안 실시간으로 DOM구조에서 렌더 트리(DOM + CSSOM)생성 >
                 레이아웃

            4. 통신, User Interface 백엔드 로직, 자바스크립트
                UI백엔드로 페이를 구축 > 클라이언트에게 페이지를 보여줍니다.
                *비동기 통신(Ajax..)이나 자바스크립트는 UI백엔드가 동작하면서 필요한 데이터를 받아오고 연산작업을 실행

        #MVC 패턴
            Model, View Controller로 기능이 분류되어 작업하는 패턴입니다.

            클라이언트에서 데이터 요청이 들어오면,
            Container에서 Servlet을 매핑하고 디스페처서블릿이
            Controller에 연결해주고, 매핑된 컨트롤러는 서비스로직을 찾아 전달합니다.(모든 전달 컨트롤은 디스페처서블릿)

            Repository를 통해서 JPA번역을 하고 DB작업 후 다시 Controller에 돌아가서
            디스패처서블릿은 ViewResolver로 HTML를 찾아가게 됩니다.
            이후 타임리프 템플릿엔진을 통해 데이터를 파싱하고 완성된 HTML를 클라이언트에게 전송하게 됩니다.
            이 작업은 Server Side Renderring 입니다.

        #만약 합격하시게 된다면 저희 회사에서 어떤 커리어를 만들어 나갈지에 대한 계획을 말씀해주세요.

            제가 만약 회사에 입사하게 된다면,
            우선 귀사에 회사원 1명으로써 일을 하고 싶다는 목표를 가지고 선임개발자를 보고 열심히 배울 것입니다.
            경험적인 부족함을 1년 내에 채우기 위한 필요한 기초지식을 항상 쌓으면 회사업무를 배우고 도움이 되도록 할 것입니다.
            네트워크의 패킷흐름이나 컴퓨터 명령어를 완벽히 배워서 구사할 수 있도록하여 행해지는 업무를 빠르게 처리할 수 있도록
            하고 싶습니다.
            3년 내에 정보보안기사 시험을 치루어 지식을 꼭 얻고 저의 커리어와 회사에 도움이 되도록 하고 싶습니다.
            5년 내에는 제가 바라는 데이터 정규화와 보안처리에 최적화된 블록체인 데이터 저장 웹서비스를 구축하여
            GITHUB를 통해 의견을 나누는 시니어 개발자가 이 회사에서 되고 싶습니다.

            거시적, 미시적

            1. 신입 개발자
            2. 성실성
            3. 미래지향석(현실적)
    Day71
        #OSI 7계층이 무엇인지 설명하시오

            OSI 7계층이 생긴 이유 : 네트워크 통신이 일어나는 과정을 단계별로 구분해서 문제가 생기는 영역을 나누어 쉽게 관리하기 위해서.

            1. Physical 계층
                비트와 같은 전기통신으로 연결되어 있는 계층으로써 케이블이나 리피터장비에서 사용하는 계층
            2. Datalink 계층
                Mac주소(기계의 고유번호)로 point to point통신하는 계층, 브릿지와 스위치 장비에서 사용하는 계층
            3. Network 계층
                라우팅(목적지까지 안전하고 빠르게 전달), 프로토콜 다양.
                흐름제어, 오류제어, 라우팅, 경로설정, IP주소부여와 같은 작업 실행
            4. Transport 계층
                TCP/UDP
                TCP(Transmission Control Protocol) 신뢰성있는 데이터, 연결기반
                UDP(User Datagram Protocol)
            5. Session 계층
                데이터를 통신하기 위한 논리적인 연결로 프로그램 관점에서 볼때 세션 설정, 유지, 종료를 운영체제 영역에서 담당
            6. presentation 계층
                확장자, 인코딩, 데이터 암호화
            7. Application 계층
                응용 서비스 수행(Springboot 서비스 등등)
                HTML의 UI등 사용자 입출력, 소프트웨어 UI같은 사용자 정보를 수집하고 연산하는 영역
                (*HTTP명령)

        #인터페이스(자바)의 의미와 사용하는 이유는 무엇인가요?

            인터페이스는 상속과 달리 강제성이라는 장점과 구현되어 있지 않으므로
            @Override를 해야합니다.

            인터페이스를 통해서 클래스를 구현할 경우,
            @override로 구현하므로 의도치 않는 버그를 방지하고(필요한 메서드만 구현)
            새로운 메서드나 모듈을 추가할 때마다 클래스 전체를 수정하지 않는 장점.

            인터페이스를 도입하면 기능 구현을 통해 우연함과 견고함을 같이 지닐 수 있다는 장점.

            예를 들어 인터페이스를 만들어 협업 규칙을 만들어 놓고 각 개발자가 개발을 할 때 메서드 이름과 매개변수 조건등
            규칙에 맞춰 개발을 한다면 대규모 프로젝트에 안정성과 빠른 개발속도를 낼 수 있습니다.
            또한 필요 없거나 필요있는 기능(메서드를 쉽게 추가하고 제거할 수 있는 기준을 가질 수 있으므로 협업에 필요한 부분입니다.)

        #스택과 큐, 덱에 대해서 알고 있는대로 말해주세요.

            -스택(Last in First Out)
                입구가 하나인 원퉁
                stack.pop은 가장 최근에 삽입된 데이터가 스택에서 제거
                스택이 비었을 때 pop을 하면 stack underflow
                스택의 크기가 꽉찼는데, push를 하면 stack overflow
                last 데이터(top)의 위치를 바로 알수 있어요 = 시간복잡도 O(1)

            -queue(First in First Out)
                양쪽이 뚫린 원퉁(일방통행).선형큐, 원형큐
                중간의 데이터 접근이 안되요.(스택과 동일)

            -deque(Double ended Queue)
                양쪽에서 모두 Push와 pop가능.
                가변적 크기와 index검색가능(중간 값 알 수 있음)
                새로운 원소를 push를 할 때 메모리 재할당 복사가 아니라 새로운 메로리 블록 형성해서 삽입.
                (가변적 구성으로 메모리 할당후 지속적 데이터 삽입 가능)
                *chunk를 통해서 관리(흩어진 메모리 영역을 관리)

        #JPA와 Mybatis차이와 회사적응
            JPA는 코드(엔티티)레벨로 관리되므로 객체지향 프로그래밍과 같이 쓸 경우 개발과 보수에 용이합니다.
            컴파일 시점에서 오류를 확인(코드가 잘못되면 오류검출이 되므로 배포하기 전에 문제를 찾을 수 있다)할 수 있고,
            DB에 종속되지 않아서 객체지향 방식으로 추상적 기술 구현 가능(DB가 아니더라도 영속화가 가능하다)하고,
            캐시, 변경감지(엔티티 수정을 통해 컴파일 단계에서 변경 내용을 서버가 알고 DB에 적용가능),
            로딩 순서변경(지연..)등 영속화 튜닝을 통해 성능상 이점을 얻을 수 있습니다.

            JPA로만은 복잡한 조인이나 연산 수행에 까다로운 단점이 있습니다.(함수, 조인을 자유롭게 쓰지 못함)
            성능상 이슈(Fetch조인, 프록시 연관관계..)를 야기할 수 있으며,
            후반 학습 곡선이 높습니다.(어차피 NativeQuery, SQL문을 알고 DB내부 구조 및 로직을 이해)

            MyBatis는 DB시점으로 SQL과 실행되는 자바 객체와 mapping하여 동작하는 라이브러리입니다.)
            SQL로 최적화된 쿼리를 구현하여 실행 할 수 있는 장점과 엔티티에 종속되지 않고 테이블을 조합하여
            CRUD가능하다는(Create, Read, Update, Delete)장점이 있습니다.

            단점으로는 스키마 변경시 SQL문 전부 변경해줘야 하는 COST가 증가하고, 중복 쿼리가 발생합니다.
            (Select 이후에 Update나 insert하는 이후 작업하는 쿼리가 있다면, 중복되는 Select문이 많이 생깁니다.)
            *런타임 단계에서 오류 검출합니다.(DB에 SQL문을 실행해야 오류 발생을 알 수 있다)
            DB에 종속된 쿼리문이므로 DB내용이 변경될 시 로직도 함께 수정해줘야 하는 단점이 있습니다.

            이러한 장단점이 있으므로, 혼용해서 사용하는 것이 가장 좋습니다. 다만,
            JPA를 사용하는 개발자와 SQL을 사용하는 개발자 모두가 필요한 단점이 있지만,
            서버 성능을 더욱 좋게 만드는 이점이 있다면 고려해볼만한 것 같습니다.
            저는 JPA를 공부하면서 NativeQuery를 썼으므로 SQL문과 JPA를 같이 활용할 수 있는 개발자입니다.
            모르는 부분은 공부하면서 회사에 도움이 되도록 노력하겠으며,
            JPA와 SQL문 모두 활용하는 프로젝트를 경험하였으므로 배우는데 아무 문제가 없습니다.
    Day73
        #HTTP 상태 코드는 5가지로 나뉘는데 분류 기준을 알려주세요
            100번대: 조건부 응답으로써 서버에서 작업 중이라는 내용의 응답코드이며,
            200번대: 서버에서 클라이언트의 요청을 인식하고 받아들였으며, 작업 진행여부를 리턴해주는 코드입니다.
            300번대: 요청 완료를 위해 추가 작업 조치가 필요하다는 코드이고,
            400번대: 클라이언트의 요청 문법이 잘못되었거나, 요청을 처리할 수 없다는 내용의 코드입니다.
            500번대: 서버에서 오류발생 코드입니다.

            *웹프로그래머 서버 개발자로서 알아야할 서버 오류 코드
            500: 서버에 오류가 발생했으나, 처리 방법을 알 수 없음.
            501: 클라이언트의 요청에 대한 서버의 응답수행기능이 없음.
            502: 게이트웨이 문제로써 보통 동시 접속자가 많아서 서버가 터졌을 때.
            503: 서버가 다운되었을 때(request요청에 대응할 준비가 되어 있지 않거나, 과부하 걸렸을 때)
            504: 응답속도가 느려서 타임아웃걸렸을 때(게이트웨이 타임아웃)

        #DB에서 인덱스를 잘 사용하면 어떤 장점이 있을까요?
            인덱스를 활용하면 빠르게 검색해주는 장점이 있습니다.(색인 검색에 용이)

            *DB 인덱스란 튜플을 빠르게 검색해주는 객체. 인덱스를 생성하면 디스크공간과 칼럼과의 연관관계에 있어 시간과 비용을 필요.

            *클러스트 인덱스: 테이블마다 튜플을 인식하게 해주는 1개의 컬럼. 물리적으로 행을 재배열하며, 데이터 입력수정삭제 시 항상 정렬상태를 유지합니다.
            검색 속도(SELECT)는 빠르나, 입력,수정,삭제는 느려요(정렬상태 유지 문제)

            *넌 클러스트 인덱스: 인덱스 페이지를 로그파일에 저장하며 인덱스 페이지만 정렬(인덱스페이징 = 자바의 참조타입의 포인터)

        #캐시교체 알고리즘 종류
            메모리에 있는 캐시정보(임시로 저장하는 스왑(input, output이 많음)이 빈번한 데이터)를 어떻게 효율적으로
            사용할지에 대한 전략을 구성하는 알고리즘 종류

            *FIFO(First In First Out)(큐같은 원통형의 알고리즘 : 먼저 들어가면 먼저 나간다)
            *LFU(Least Frequenty Used): 오래된 사용 캐쉬부터 적용되는 알고리즘
            *LRU(Least Recently Used): 많이 사용되지 않은 캐쉬 정보부터 적용되는 알고리즘

            사용자에게 빠르게 정보를 제공하기 위해 사용되는 캐시에서
            새로운 데이터가 발생했을 때 "가장 오래전에 사용된 데이터"를 제거하여
            새로운 데이터를 넣는 알고리즘

        #자신과 너무 안 맞는 사람이 있고 그로 인해 갈등이 생긴다면 어떻게 대처하실 건가요?
            (팀의 분위기와 커뮤니케이션이 잘 되는지 확인하는 심리 질문)
            상사나 혹은 팀장에게 본인의 의사를 전달하면서 팀에 잘 융화될 수 있도록 이타적인 이야기를 전달.
            팀장에게 저의 이런 부분이 부족해서 갈등 빗고 있습니다. 그래서 최선을 다해 팀에 도움이 되도록 야근을 하며
            업무를 적응하지만, 팀 분위기가 흐려지는 것에 고민이 있습니다.
            저는 그 분과 대화를 나누고 싶은데, 혹시 팀장님께서 자리를 만들어 주실 수 있을런지요?


    -----------------------------------------------------------------------
    모르는 용어


    Argument = 전달인자, 인자 (함수와 메서드의 입력값(Value)

    의존 객체(Dependency Injection) DI = 의존관계 주입

    @Autowired
        타입매칭

        의존관계를 자동으로 주입

        의존 객체를 주입하는 방식으로 총 4가지 방식이 있음
        Constructor based Injection(생성자 주입),
        필드 주입,
        Setter Based Injection 방식(수정자 주입),
        일반 메서드 주입

    @AllArgsConstructor
        Class 모든 필드 값을 파라미터로 받는 생성자를 추가합니다.
        필드에 쓴 모든 생성자만 만들어줌(전달 인수가 필요함)

    @BatchSize(size=100)
        최대 100(n)개까지 한꺼번에 불러오겠다는 세팅

    @Builder
        빌더패턴을 만들어줌

    @Column(length = 40, nullable = false, unique = true)
        객체 필드를 테이블 컬럼과 매핑한다.

    @CreatedDate
        생성된 시간 정보 자동으로 저장

    @ColumnDefault("'no content'")
        해당 컬럼의 default value를 지정한다.

    @Controller
        Spring에게 해당 Class가 Controller의 역활을 한다고 명시하기 위해 사용하는 Annotation입니다.

    @Data
        getter, setter 만들어줌

    @DisplayName("저장, 데이터가 잘 들어갔는지 확인")
        테스트결과를 한눈에 보기편하게 하기 위해 쓰는 어노테이션

    @EntityListeners(AuditingEntityListener.class)
        AuditingEntityListener클래스가 callback listener로 지정되어 Entity에서 이벤트가 발생할 때마다 특정 로직을 수행

    @EnableJpaAuditing
        main method가 있는 클래스에 적용하며, JPA Auditing(감시, 감사)기능을 활성화하기 위한 어노테이션.
        CreateDate, modifiedDate처럼 DB에 데이터가 저장되거나 수정될 때 언제, 누가 했는지를 자동으로 관리할 수 있게 됨.

    @Entity
        테이블과 매핑
        @Entity가 붙은 클래스는 JPA가 관리하는 것으로, 엔티티라고 불림

    Eager(즉시 로딩)

    @GeneratedValue
        기본 키 맵핑
        자동생성 : 대리 키 사용 방식

    @GetMapping
        RequestMapping(Method=RequestMethod.GET)과 똑같은 역할을 합니다.

    @Getter
        Class 모든 필드의 Getter method를 생성해줍니다.

    @Id
        엔티티의 기본키 필드에 값을 직접 넣어 등록한다.

    @JoinColumn(name = "id", referencedColumnName = "id")

    @LastModifiedDate
        수정된 시간정보 자동 저장

    @ModelAttribute
        클라이언트가 전송하는 HTTP parameter, Body 내용을 Setter 함수를 통해 1:1로 객체에 데이터를 연결(바인딩)합니다.
        RequestBody와 다르게 HTTP Body 내용은 multipart/form-data 형태를 요구합니다.
        @RequestBody가 json을 받는 것과 달리 @ModenAttribute 의 경우에는 json을 받아 처리할 수 없습니다.

    @MappedSuperclass
        객체의 입장에서 '생성시간', '수정시간' 같은 공통 매핑 정보가 필요할 때 사용됨

    @ManyToOne(fetch = FetchType.LAZY)


    @NoArgsConstructor
        기본 생성자를 만들어 줌(전달인수가 필요 없음)
        Class 기본 생성자를 자동으로 추가해줍니다.


    @OneToMany(mappedBy = "member")

    @Override

    @PostMapping("/insertComments")
        RequestMapping(Method=RequestMethod.POST)과 똑같은 역할을 합니다.

    Parameter = 매개변수 (함수와 메서드 입력 변수(Variable)명

    @Query(value = "select m from Member m where m.email = :email_1 or m.id = :id_1")

    @RequestMapping
        Request의 header값을 가져올 수 있으며, 해당 Annotation을 쓴 메소드의 파라미터에 사용합니다.

    @RequestBody
        Body에 전달되는 데이터를 메소드의 인자와 매칭시켜,
        데이터를 받아서 처리할 수 있는 Annotation으로 아래와 같이 사용합니다.
        클라이언트가 보내는 HTTP 요청 본문(JSON 및 XML 등)을 Java 오브젝트로 변환합니다.
        아래와 같이 사용합니다.
        클라이언트가 body에 json or xml 과 같은 형태로 형태로 값(주로 객체)를 전송하면,
        해당 내용을 Java Object로 변환합니다.

    @ResponseBody
        @ResponseBody은 메소드에서 리턴되는 값이 View 로 출력되지 않고
        HTTP Response Body에 직접 쓰여지게 됩니다.
        return 시에 json, xml과 같은 데이터를 return 합니다.

    @Slf4j

    @Service
        서비스 계층에 대한 고정관념

    @SpringBootApplication
        스프링 부트의 가장 기본적인 설정을 선언해 줍니다.

    @SequenceGenerator
        기본 키 매핑 시퀀스 전략
        시퀀스는 유일한 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트입니다.

    @Setter
        Class 모든 필드의 Setter method를 생성해줍니다.

    @ToString
        필드값 = 값 형식으로 저장함
        (seq = 1, id = user)
        Class 모든 필드의 toString method를 생성한다.

    @Test
        JUnit에서 테스트 할 대상을 표시합니다.

    @Temporal(TemporalType.DATE)
        @Temporal은 날짜 타입을 매핑할 때 사용한다

    @Transient
        영속성에 관한 것
        Entity를 사용하면 컬럼으로 표기되는데
        Transient를 사용하면 테이블의 컬럼과 맵핑하지 않음
        하지만 다른 곳에서 호출 가능하기 때문에 List 형식으로 넣는 것이 좋음

    -----------------------------------------------------------------------
    취업
        빅데이터
                PyTorch (연구용 자료기 때문에 무료)
                Tensorflow

            클라우드 개발
            구름IDE

            EXPO

    -----------------------------------------------------------------------

    새로오신 선생님
        박수민
        foxman12@hanmail.net
        010-2211-3805

        https://cafe.naver.com/grapec